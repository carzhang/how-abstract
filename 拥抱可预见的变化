拥抱可预见的变化 

1 
什么代码是beautiful的？
如果以后不迭代，说明没有变化，这代码适合场景，就是beautiful的代码。 
如果以后出现变化，那就根据变化来修改，变化驱动开发。比如这时就可以用抽象，
封装同一类型的变化，使对这样的变化是OCP的。
于是，新的代码又适应了新的场景。
这时，没有cover未出现的变化，只cover了当前出现的变化。

2 
为什么要cover未出现的变化呢？
如果到这个软件死了，变化都没有出现，那我是不是过度设计了？
所以，我的观点是：变化驱动开发。
于是，别人review我的代码，心里活动是“fuck, 你懂不懂抽象？你讲不讲style?”
我看了别人的comments后，心里活动同上，“谁不懂抽象？这是哪门子style?”

3 
为什么一定要成功预言呢？
预言，有成功，有失败。成功与失败是一对矛盾。想要成功，同时就要接受失败。
想要成功，不要失败，是不现实的。
对未来可能发生的变化进行cover，成功与失败，都要欣然接受。
比如iCellState，抽象一下，封装变化，修改成cellState,当以后cellState变成 boolean类型时，
就不用把名字改成bCellState。如果软件到死，都一直是int型，那接受猜测不成功的结果就好了，这是正常的！

4 
自己可预见的变化 + 别人可预见的变化 = 可预见的变化。
我们是可以cover这些变化的。
毕竟，变化是必然的，没预见，自不必说了；既然预见了，为什么不cover呢？
如果1991年的Linus ，就能预见变化，就能做出linux2.6,这个世界不就更美好了吗？

5
什么是High quality?
一屋子的人review代码时，funk的次数最少的代码，即是质量最好的代码。
